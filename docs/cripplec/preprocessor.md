---
sidebar_position: 3
draft: true
---

# 预处理器

> ⚠️ 你先别急 ⚠️ 🚧 本页面仍在施工中 🚧

## 宏是文本替换

看到这个标题你可能有些疑惑，宏当然是文本替换了，不然还能是什么？

是的，当我们剥离上下文讨论这个话题的时候，所有人似乎都能答对；但是一旦到了某个具体的场景，潜意识总是占据主导地位，而忽略了宏是文本替换的本质。

### 宏不是类型定义

一种常见的误解是，认为 `#define` 能完全代替 `typedef` 的功能。例如

```c
typedef int Cake;
Cake i;
```

和

```c
#define Cake int
Cake i;
```

看上去没什么区别。

但是一旦事情复杂起来，例如

```c
typedef int* CakePtr1;
CakePtr1 p1, p2;
#define CakePtr2 int*
CakePtr2 p3, p4;
```

很快问题就浮现了出来。作为一个整体，`CakePtr1` 代表了 `int*`。所以 `p1` 和 `p2` 都是 `int*`

但是作为一个宏 `CakePtr2` 在替换完成之后的结果是

```c
int* p3, p4;
```

此时只有 `p3` 是 `int*`，`p4` 则是 `int`

更不要说 `typedef`  本身提供的语法层面的支持，可以支持更高级的情形：

```c
typedef int (*table_t)[10];
typedef table_t lookup_t(int);
lookup_t* lookups[10];
// 等价于
int (*(*lookups[10])(int))[10];
```

有关这一部分的详细讨论，参见 cdecl 一节。

### 宏不是函数定义

函数调用带来的开销会让一些人选择把简单的函数定义为宏，例如

```c
#define twice(x) x + x
```

问题在于以下两种情况：

例如 `twice(2>>1)` 会被展开为 `2>>1+2>>1`，即 `2>>(1+2)>>1` 结果为 0

这表明参数本身需要被括号包围。

同时 `twice(1)*2` 会被展开为 `1+1*2`，结果为 3

这表明整个表达式也需要被括号包围。 

综上所述，一般宏会被完善成这样：

```
#define twice(x) ((x) + (x))
```

但是这样的定义仍然存在严重的问题，那就是表达式带来的副作用。

例如 `twice(++x)` 会被展开为 `++x + ++x`，且不论结果会是多少，`x` 被递增了两次可能也是出乎预料的。 

由此可见，把函数定义为一个宏会带来巨大的隐患。相比之下，直接编写和调用简单的函数，往往能够被编译器识别和内联，并不会增加运行时的开销。

### 宏不是常量定义

很遗憾，宏也不是常量的定义。

```
#define TWENTY 10+10
TWENTY*2 // 30
```

#### 宏与逗号

#### 可变参数宏

#### \# 和 \#\#

## `__func__` 不是宏

`__FILE__` 和 `__LINE__` 的命名可能会让人误以为 `__func__` 也是宏。但其实不是。

## Header Guard