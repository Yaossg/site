# ğŸ—³ æ•™æˆ‘å”±ç¥¨

## é¢˜ç›®

XuKaFy åˆšåˆšå¼€å§‹å­¦ä¹ å¹¶å‘ã€‚ä»–ç”¨ C å†™äº†ä¸€ä¸ªæ¨¡æ‹Ÿå”±ç¥¨ç¨‹åºï¼š

```C
// count.c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

volatile int counter = 0;
volatile int bucket[32768] = {0};

typedef struct {
    int count;
    int* start;
} Task;

void* fun(void* arg) {
    Task* task = (Task*) arg;
    for (int i = 0; i < task->count; ++i) {
        ++counter;
        ++bucket[task->start[i]];
    }
    return NULL;
}

int main(int argv, char* argc[]) {
    if(argv != 2) {
        printf("Usage: count <value>\n");
        return 0;
    }

    int n = atoi(argc[1]);
    if(n <= 0) {
        printf("Invalid value\n");
        return 0;
    }
    printf("n = %d\n", n);

    int* ticket = (int*) malloc(sizeof(int) * n);
    for (int i = 0; i < n; ++i) {
        ticket[i] = rand() % 32768;
    }

    Task t1 = {n / 2, ticket};
    Task t2 = {n / 2 + (n % 2), ticket + n / 2};
    pthread_t p1, p2;

    pthread_create(&p1, NULL, fun, (void*) &t1);
    pthread_create(&p2, NULL, fun, (void*) &t2);
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf("Counter = %d\n", counter);

    int count = 0;
    for (int i = 0; i < 32768; ++i) {
        count += bucket[i];
    }
    printf("Count = %d\n", count);

    free(ticket);
    return 0;
}
```

å…¶ä¸­ï¼Œ`n` æ˜¯çœŸå®ç¥¨æ•°ï¼Œ`Counter` ä¸ºä¸¤ä¸ªçº¿ç¨‹åŠ èµ·æ¥çš„å”±ç¥¨æ•°ï¼Œ`Count` ä¸ºæ¡¶è®¡æ•°ä»¥åçš„ç¥¨æ•°ã€‚

å½“ç„¶ï¼Œå½“ `n` æ¯”è¾ƒå°çš„æ—¶å€™ï¼ŒXuKaFy çš„å”±ç¥¨ç¨‹åºæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œç›´åˆ°æŸä¸€å¤©ï¼š

```
prompt> ./count 200000
n = 200000
Counter = 108201
Count = 199996
```

XuKaFy æå…¶ä¸è§£ï¼Œä»–åˆè¿è¡Œäº†å‡ éï¼Œå‘ç°ä¼¼ä¹æœ‰è¿™æ ·ä¸€ä¸ªè§„å¾‹ï¼š

$$
n \geq Count \geq Counter
$$

åæ¥ï¼ŒXuKaFy çŸ¥é“ `valgrind` å¯ä»¥æ£€æŸ¥å†…å­˜æ³„æ¼ï¼Œç„¶åå°±è¯•äº†ä¸€ä¸‹ï¼š

```
prompt> valgrind --leak-check=yes ./count 1000000
==837== Memcheck, a memory error detector
==837== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==837== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==837== Command: ./count 1000000
==837== 
n = 1000000
Counter = 1000000
Count = 1000000
==837== 
==837== HEAP SUMMARY:
==837==     in use at exit: 0 bytes in 0 blocks
==837==   total heap usage: 4 allocs, 4 frees, 4,001,568 bytes allocated
==837== 
==837== All heap blocks were freed -- no leaks are possible
==837== 
==837== For lists of detected and suppressed errors, rerun with: -s
==837== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```


è™½ç„¶æ²¡æœ‰å†…å­˜æ³„éœ²ï¼Œä½†æ˜¯ï¼š

$$
n = Count = Counter
$$

è¯·ä½ è§£é‡Šè§£é‡Šä¸ºä»€ä¹ˆï¼Œå¹¶ä¸”å¸® XuKaFy æ”¹æ”¹ä»£ç ã€‚

## é¢˜è§£

### è§£é‡Š

è‡ªå¢æ—¶ï¼Œå˜é‡å…ˆè¢«ä»å†…å­˜ä¸­å¤åˆ¶åˆ°å¯„å­˜å™¨é‡Œï¼Œç„¶åå®Œæˆè‡ªå¢æ“ä½œï¼Œå†é‡æ–°å†™å›å†…å­˜ã€‚å½“å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€ä¸ªå˜é‡è¿›è¡Œè‡ªå¢çš„æ—¶å€™ï¼Œä¼šå‡ºç°ä¸‹é¢è¿™ç§æƒ…å½¢ï¼šï¼ˆå›¾ä¸­å·¦ä¾§å³ä¾§ä¸ºä¸¤ä¸ªçº¿ç¨‹çš„å¯„å­˜å™¨ï¼Œä¸­é—´ä¸ºå…±åŒæ“ä½œçš„å˜é‡ï¼‰

![](3.png)



ç»“æœæ˜¯ï¼šä¸¤æ¬¡è‡ªå¢ï¼Œå˜é‡å´åªåŠ äº†ä¸€ã€‚è‡ªå¢å¾—è¶Šé¢‘ç¹ï¼Œè¿™æ ·çš„æƒ…å†µå°±ä¼šå‘ç”Ÿçš„è¶Šå¤šã€‚

å¯¹äº `counter` æ¥è¯´ï¼Œæ‰€æœ‰çš„ç¥¨éƒ½ä¼šä½¿å®ƒè‡ªå¢ã€‚ä½†æ˜¯å¯¹äº `bucket` çš„æ¯ä¸€ä¸ªå…ƒç´ è€Œè¨€ï¼Œåªæœ‰éƒ¨åˆ†çš„ç¥¨ä¼šä½¿å®ƒè‡ªå¢ã€‚åè€…è‡ªå¢æ²¡æœ‰å‰è€…é‚£ä¹ˆé¢‘ç¹ï¼Œæ‰€ä»¥æœ€å `counter` å‘ç”Ÿä¸Šé¢æƒ…å½¢çš„æœºä¼šè¿œé«˜äºæ‰€æœ‰ `bucket` çš„å…ƒç´ ä¹‹å’Œã€‚

ç”±æ­¤å¯å¾—ï¼š
$$
n \geq Count \geq Counter
$$

### ä¿®æ”¹

ä½¿ç”¨äº† C11 çš„ `_Atomic`ã€‚

```C
// modified count.c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

_Atomic int counter = 0;
_Atomic int bucket[32768] = {0};

typedef struct {
    int count;
    int* start;
} Task;

void* fun(void* arg) {
    Task* task = (Task*) arg;
    for (int i = 0; i < task->count; ++i) {
        ++counter;
        ++bucket[task->start[i]];
    }
    return NULL;
}

int main(int argv, char* argc[]) {
    if(argv != 2) {
        printf("Usage: count <value>\n");
        return 0;
    }

    int n = atoi(argc[1]);
    if(n <= 0) {
        printf("Invalid value\n");
        return 0;
    }
    printf("n = %d\n", n);

    int* ticket = (int*) malloc(sizeof(int) * n);
    for (int i = 0; i < n; ++i) {
        ticket[i] = rand() % 32768;
    }

    Task t1 = {n / 2, ticket};
    Task t2 = {n / 2 + (n % 2), ticket + n / 2};
    pthread_t p1, p2;

    pthread_create(&p1, NULL, fun, (void*) &t1);
    pthread_create(&p2, NULL, fun, (void*) &t2);
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    printf("Counter = %d\n", counter);

    int count = 0;
    for (int i = 0; i < 32768; ++i) {
        count += bucket[i];
    }
    printf("Count = %d\n", count);

    free(ticket);
    return 0;
}
```

### valgrind

valgrind çš„æ£€æŸ¥æœ‰æ•ˆå†…å­˜çš„åŸç†æ˜¯ç»™å¯ç”¨åœ°å€æ‰“è¡¨ã€‚ä¸ºäº†æ”¯æŒå¤šçº¿ç¨‹ï¼Œè¿™ä¸ªè¡¨æ˜¯ä¸Šäº†é”çš„ã€‚å½“è®¿é—®æŸä¸ªåœ°å€çš„æ—¶å€™ï¼Œvalgrind ä¼šå»æŸ¥è¿™ä¸ªè¡¨ï¼Œè¡¨å°±è¢«é”äº†ï¼Œäºæ˜¯å…¶ä»–æƒ³è¦è®¿é—®è¿™ä¸ªåœ°å€çº¿ç¨‹åªèƒ½å…ˆç­‰ç€ã€‚æ‰€ä»¥æœ€åæ‰€æœ‰è‡ªå¢éƒ½æœ‰åºè¿›è¡Œï¼Œæ²¡æœ‰å‘ç”Ÿå‰é¢é‡åˆ°çš„æƒ…å†µã€‚
